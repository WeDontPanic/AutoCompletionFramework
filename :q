implement japanese index bulider
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Your branch is up to date with 'origin/master'.
#
# Changes to be committed:
#	modified:   Cargo.lock
#	modified:   Cargo.toml
#	modified:   src/index/basic/builder.rs
#	modified:   src/index/basic/mod.rs
#	new file:   src/index/japanese/builder.rs
#	modified:   src/index/japanese/mod.rs
#	modified:   src/index/mod.rs
#	modified:   src/index/ngram/builder.rs
#	modified:   src/index/ngram/mod.rs
#	deleted:    src/index/ngram_ext/builder.rs
#	deleted:    src/index/ngram_ext/mod.rs
#
# ------------------------ >8 ------------------------
# Do not modify or remove the line above.
# Everything below it will be ignored.
diff --git a/Cargo.lock b/Cargo.lock
index 56e4faf..091b43b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -33,6 +33,7 @@ dependencies = [
  "criterion",
  "eudex",
  "jpeudex",
+ "ngindex",
  "ngram-tools",
  "order_struct",
  "priority_container",
@@ -432,6 +433,15 @@ version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e4a24736216ec316047a1fc4252e27dabb04218aa4a3f37c6e7ddbf1f9782b54"
 
+[[package]]
+name = "ngindex"
+version = "0.1.0"
+dependencies = [
+ "ngram-tools",
+ "serde",
+ "vector_space_model2",
+]
+
 [[package]]
 name = "ngram-tools"
 version = "0.1.0"
diff --git a/Cargo.toml b/Cargo.toml
index fd7a5a6..66bf5a6 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -20,6 +20,7 @@ order_struct = { git = "https://github.com/JojiiOfficial/OrderStruct" }
 eudex = { git = "https://github.com/WeDontPanic/eudex" }
 vector_space_model2 = { path = "../VectorSpaceModel" }
 ngram-tools = { git = "https://github.com/JojiiOfficial/ngram-tools" }
+ngindex = { path = "../ngindex" }
 
 [dev-dependencies]
 criterion = "0.3.5"
diff --git a/src/index/basic/builder.rs b/src/index/basic/builder.rs
index 7ee2e99..53e85d9 100644
--- a/src/index/basic/builder.rs
+++ b/src/index/basic/builder.rs
@@ -1,8 +1,6 @@
-use qp_trie::{wrapper::BString, Trie};
-
-use crate::index::ngram_ext::builder::NGIndexBuilder;
-
 use super::{BasicIndex, Item};
+use ngindex::builder::NGIndexBuilder;
+use qp_trie::{wrapper::BString, Trie};
 
 pub struct BasicIndexBuilder {
     build_ng_index: bool,
diff --git a/src/index/basic/mod.rs b/src/index/basic/mod.rs
index e41d97f..6321508 100644
--- a/src/index/basic/mod.rs
+++ b/src/index/basic/mod.rs
@@ -2,9 +2,10 @@ pub mod builder;
 pub mod item;
 
 pub use item::Item;
+use ngindex::NGIndex;
 use order_struct::{float_ord::FloatOrd, order_nh::OrderVal, OrderBy};
 
-use super::{ngram_ext::NGIndex, IndexItem, NGIndexable, SuggestionIndex};
+use super::{IndexItem, NGIndexable, SuggestionIndex};
 use crate::relevance::item::EngineItem;
 use priority_container::{PrioContainer, PrioContainerMax};
 use qp_trie::{wrapper::BString, Trie};
@@ -105,7 +106,7 @@ impl SuggestionIndex for BasicIndex {
 
 impl NGIndexable for BasicIndex {
     fn similar(&self, query: &str, limit: usize) -> Vec<EngineItem> {
-        let q_vec = match self.ngram.query_vec(query) {
+        let q_vec = match self.ngram.make_query_vec(query) {
             Some(q) => q,
             None => return vec![],
         };
diff --git a/src/index/japanese/builder.rs b/src/index/japanese/builder.rs
new file mode 100644
index 0000000..2af3b2f
--- /dev/null
+++ b/src/index/japanese/builder.rs
@@ -0,0 +1,137 @@
+use super::{Item, JapaneseIndex};
+use ngindex::{builder::NGIndexBuilder, NGIndex};
+use qp_trie::{wrapper::BString, Trie};
+use std::collections::{HashMap, HashSet};
+
+/// Helper to build a new japanese autocompletion index
+pub struct JpIndexBulider {
+    build_ng_index: bool,
+    n: usize,
+    ng_map: HashMap<String, HashSet<u32>>,
+
+    trie: Trie<BString, Vec<u32>>,
+    items: Vec<Item>,
+    kanji_align: Trie<BString, Vec<u32>>,
+}
+
+impl JpIndexBulider {
+    pub fn new() -> Self {
+        Self {
+            build_ng_index: false,
+            n: 0,
+            ng_map: HashMap::new(),
+
+            trie: Trie::new(),
+            items: vec![],
+            kanji_align: Trie::new(),
+        }
+    }
+
+    pub fn with_ngindex(n: usize) -> Self {
+        Self {
+            build_ng_index: true,
+            n,
+            ng_map: HashMap::new(),
+
+            trie: Trie::new(),
+            items: vec![],
+            kanji_align: Trie::new(),
+        }
+    }
+
+    /// Adds an item to the new index. Uses the items readings as keys.
+    /// Does not index kanji reading align and normal_kana since `item` doesn't hold that data
+    /// Returns the id of the new item
+    pub fn add_item(&mut self, item: Item) -> u32 {
+        let id = self.items.len() as u32;
+
+        self.insert_trie(&item.kana, id);
+
+        if let Some(ref kanji) = item.kanji {
+            self.insert_trie(kanji, id);
+        }
+
+        for alt in &item.alternative {
+            self.insert_trie(alt, id);
+        }
+
+        self.items.push(item);
+        id
+    }
+
+    /// Inserts `item` into the new index and uses all strings in `readings` to map to this item.
+    /// Returns the id of the new item
+    pub fn insert<S: AsRef<str>>(&mut self, readings: &[S], item: Item) -> u32 {
+        let id = self.items.len() as u32;
+        self.items.push(item);
+
+        for reading in readings {
+            self.insert_trie(reading.as_ref(), id);
+        }
+
+        id
+    }
+
+    /// Adds readings that'll map to the item with the given ID
+    pub fn add_readings<S: AsRef<str>>(&mut self, readings: &[S], id: u32) {
+        for reading in readings {
+            self.insert_trie(reading.as_ref(), id);
+        }
+    }
+
+    /// Inserts all readings into the ngram index and maps to the item with `id`
+    pub fn insert_ng<S: AsRef<str>>(&mut self, readings: &[S], id: u32) {
+        if !self.build_ng_index {
+            return;
+        }
+
+        for reading in readings.iter().map(|i| i.as_ref()) {
+            self.ng_map
+                .entry(reading.to_string())
+                .or_default()
+                .insert(id);
+        }
+    }
+
+    pub fn insert_kalign<S: AsRef<str>>(&mut self, readings: &[S], id: u32) {
+        for reading in readings {
+            insert_or_update(&mut self.kanji_align, reading.as_ref(), id);
+        }
+    }
+
+    /// Create a JapaneseIndex out of the builder
+    pub fn build(self) -> JapaneseIndex {
+        let mut ngindex = NGIndex::default();
+        if self.build_ng_index {
+            ngindex = Self::build_ngindex(self.n, self.ng_map);
+        }
+
+        JapaneseIndex {
+            trie: self.trie,
+            items: self.items,
+            kanji_align: self.kanji_align,
+            ngindex,
+        }
+    }
+
+    fn build_ngindex(n: usize, ng_map: HashMap<String, HashSet<u32>>) -> NGIndex<Vec<u32>> {
+        let mut builder = NGIndexBuilder::<Vec<u32>>::new(n);
+        for (term, ids) in ng_map {
+            let ids = ids.into_iter().collect();
+            builder.insert(&term, ids);
+        }
+        builder.build()
+    }
+
+    fn insert_trie(&mut self, reading: &str, id: u32) {
+        insert_or_update(&mut self.trie, reading, id);
+    }
+}
+
+fn insert_or_update(trie: &mut Trie<BString, Vec<u32>>, item: &str, id: u32) {
+    if let Some(v) = trie.get_mut_str(item) {
+        v.push(id);
+    } else {
+        trie.insert_str(item, vec![id]);
+    }
+}
diff --git a/src/index/japanese/mod.rs b/src/index/japanese/mod.rs
index 6c3a916..f911c7c 100644
--- a/src/index/japanese/mod.rs
+++ b/src/index/japanese/mod.rs
@@ -1,11 +1,13 @@
+pub mod builder;
 pub mod item;
 
 pub use item::Item;
+use ngindex::NGIndex;
 use serde::{Deserialize, Serialize};
 
-use super::{IndexItem, KanjiReadingAlign, SuggestionIndex};
+use super::{IndexItem, KanjiReadingAlign, NGIndexable, SuggestionIndex};
 use crate::relevance::item::EngineItem;
-use order_struct::{float_ord::FloatOrd, OrderBy};
+use order_struct::{float_ord::FloatOrd, order_nh::OrderVal, OrderBy};
 use priority_container::{PrioContainer, PrioContainerMax};
 use qp_trie::{wrapper::BString, Trie};
 use std::collections::HashSet;
@@ -16,72 +18,11 @@ pub struct JapaneseIndex {
     pub trie: Trie<BString, Vec<u32>>,
     pub items: Vec<Item>,
     kanji_align: Trie<BString, Vec<u32>>,
-}
-
-pub struct InsertItem {
-    item: Item,
-    kanji_aligns: Vec<String>,
-    normal_kana: Option<String>,
-}
 
-impl InsertItem {
-    #[inline]
-    pub fn new(item: Item, kanji_aligns: Vec<String>) -> Self {
-        Self {
-            item,
-            kanji_aligns,
-            normal_kana: None,
-        }
-    }
-
-    /// Set the insert item's normal kana.
-    #[inline]
-    pub fn set_normal_kana(&mut self, normal_kana: Option<String>) {
-        self.normal_kana = normal_kana;
-    }
+    ngindex: NGIndex<Vec<u32>>,
 }
 
 impl JapaneseIndex {
-    /// Build a new JapaneseIndex
-    pub fn new(items: Vec<InsertItem>) -> Self {
-        let mut trie = Trie::new();
-        let mut kanji_align = Trie::new();
-
-        let mut index_item = Vec::with_capacity(items.len());
-
-        for (pos, iitem) in items.iter().enumerate() {
-            let id = pos as u32;
-            let kanji_aligns = &iitem.kanji_aligns;
-            let item = iitem.item.clone();
-
-            insert_or_update(&mut trie, &item.kana, id);
-
-            if let Some(ref kanji) = item.kanji {
-                insert_or_update(&mut trie, kanji, id);
-            }
-
-            for alt in &item.alternative {
-                insert_or_update(&mut trie, &alt, id);
-            }
-
-            for item in kanji_aligns {
-                insert_or_update(&mut kanji_align, &item, id);
-            }
-
-            if let Some(ref i) = iitem.normal_kana {
-                insert_or_update(&mut trie, i, id);
-            }
-
-            index_item.push(item);
-        }
-
-        Self {
-            trie,
-            items: index_item,
-            kanji_align,
-        }
-    }
-
     #[inline]
     pub fn get_item(&self, id: u32) -> &Item {
         &self.items[id as usize]
@@ -116,6 +57,10 @@ impl SuggestionIndex for JapaneseIndex {
     }
 
     fn similar_terms(&self, inp: &str, limit: usize, max_dist: u32) -> Vec<EngineItem> {
+        let inp_len = inp.trim().chars().count();
+        if inp_len <= 1 {
+            return vec![];
+        }
         let query_hash = match jpeudex::Hash::new(inp) {
             Some(h) => h,
             None => return vec![],
@@ -180,11 +125,35 @@ impl KanjiReadingAlign for JapaneseIndex {
     }
 }
 
-fn insert_or_update(trie: &mut Trie<BString, Vec<u32>>, item: &str, id: u32) {
-    if let Some(v) = trie.get_mut_str(item) {
-        v.push(id);
-    } else {
-        trie.insert_str(item, vec![id]);
+impl NGIndexable for JapaneseIndex {
+    fn similar(&self, query: &str, limit: usize) -> Vec<EngineItem> {
+        let q_vec = match self.ngindex.make_query_vec(query) {
+            Some(q) => q,
+            None => return vec![],
+        };
+
+        let mut prio_queue = PrioContainerMax::new(limit);
+
+        let res_iter = self
+            .ngindex
+            .find_qweight(&q_vec, 0.64)
+            .map(|(id, sim)| OrderVal::new(id, FloatOrd(sim)));
+        prio_queue.extend(res_iter);
+
+        let mut out: Vec<_> = prio_queue
+            .into_iter()
+            .map(|i| {
+                let rel = i.0.ord().0;
+                i.0.into_inner()
+                    .into_iter()
+                    .map(|i| EngineItem::new(self.get_item(i), (rel * 1000.0) as u16))
+                    .collect::<Vec<_>>()
+            })
+            .flatten()
+            .collect();
+
+        out.reverse();
+        out
     }
 }
 
diff --git a/src/index/mod.rs b/src/index/mod.rs
index 1a2ef4f..6b7a7b2 100644
--- a/src/index/mod.rs
+++ b/src/index/mod.rs
@@ -1,7 +1,9 @@
+/// Generic index
 pub mod basic;
+/// Index for Japanese terms
 pub mod japanese;
+/// Raw N-gram based index
 pub mod ngram;
-pub mod ngram_ext;
 pub mod output;
 pub mod str_item;
 
@@ -28,13 +30,6 @@ pub trait SuggestionIndex {
     fn exact(&self, inp: &str) -> Vec<EngineItem>;
     fn get_word(&self, id: u32) -> Option<EngineItem>;
 
-    /*
-    #[inline]
-    fn str_relevance(&self, id: u32, query: &str) -> u16 {
-        self.get_word(id).unwrap().inner().str_relevance(query)
-    }
-    */
-
     #[inline]
     fn similar_terms(&self, _inp: &str, _limit: usize, _max_dist: u32) -> Vec<EngineItem> {
         vec![]
diff --git a/src/index/ngram/builder.rs b/src/index/ngram/builder.rs
index cff8522..2bb1bae 100644
--- a/src/index/ngram/builder.rs
+++ b/src/index/ngram/builder.rs
@@ -1,3 +1,5 @@
+use ngindex::builder::NGIndexBuilder;
+
 use super::item::Item;
 use super::NgramIndex;
 use std::collections::HashMap;
@@ -28,7 +30,7 @@ impl NgramIndexBuilder {
     }
 
     pub fn build(self) -> NgramIndex {
-        let mut builder = super::super::ngram_ext::builder::NGIndexBuilder::<Vec<u32>>::new(self.n);
+        let mut builder = NGIndexBuilder::<Vec<u32>>::new(self.n);
 
         for (term, out) in self.index_str {
             let out: Vec<_> = out.into_iter().map(|i| i as u32).collect();
diff --git a/src/index/ngram/mod.rs b/src/index/ngram/mod.rs
index 96f3fcd..52dea63 100644
--- a/src/index/ngram/mod.rs
+++ b/src/index/ngram/mod.rs
@@ -2,8 +2,9 @@ pub mod builder;
 pub mod item;
 
 pub use item::Item;
+use ngindex::NGIndex;
 
-use super::{ngram_ext::NGIndex, IndexItem, SuggestionIndex};
+use super::{IndexItem, SuggestionIndex};
 use crate::relevance::item::EngineItem;
 use priority_container::PrioContainerMax;
 use serde::{Deserialize, Serialize};
@@ -31,7 +32,7 @@ impl NgramIndex {
 
     #[inline]
     fn build_query(&self, s: &str) -> Option<Vector> {
-        self.index.query_vec(s)
+        self.index.make_query_vec(s)
     }
 
     pub fn n(&self) -> usize {
diff --git a/src/index/ngram_ext/builder.rs b/src/index/ngram_ext/builder.rs
deleted file mode 100644
index a3a3524..0000000
--- a/src/index/ngram_ext/builder.rs
+++ /dev/null
@@ -1,50 +0,0 @@
-use std::io::Cursor;
-
-use ngram_tools::iter::wordgrams::Wordgrams;
-use vector_space_model2::{
-    build::IndexBuilder,
-    metadata::IndexVersion,
-    traits::{Decodable, Encodable},
-    DefaultMetadata, Index,
-};
-
-use super::NGIndex;
-
-pub struct NGIndexBuilder<I: Decodable + Encodable> {
-    builder: IndexBuilder<I>,
-    n: usize,
-}
-
-impl<I: Decodable + Encodable> NGIndexBuilder<I> {
-    pub fn new(n: usize) -> Self {
-        let builder = IndexBuilder::<I>::new();
-        Self { builder, n }
-    }
-
-    pub fn insert(&mut self, term: &str, id: I) -> bool {
-        let term_len = term.chars().count();
-        if term_len < self.n {
-            return false;
-        }
-
-        let padded = super::padded(term, self.n - 1);
-        let terms: Vec<_> = self.split_term(&padded).collect();
-        self.builder.insert_new_vec(id, &terms);
-
-        true
-    }
-
-    pub fn build(self) -> NGIndex<I> {
-        let mut buf = vec![];
-        self.builder
-            .build(&mut buf, DefaultMetadata::new(IndexVersion::V1))
-            .unwrap();
-        let index = Index::<I, DefaultMetadata>::from_reader(Cursor::new(buf)).unwrap();
-        NGIndex::new(index, self.n)
-    }
-
-    #[inline]
-    fn split_term<'a>(&self, term: &'a str) -> Wordgrams<'a> {
-        Wordgrams::new(term, self.n)
-    }
-}
diff --git a/src/index/ngram_ext/mod.rs b/src/index/ngram_ext/mod.rs
deleted file mode 100644
index f41d0fb..0000000
--- a/src/index/ngram_ext/mod.rs
+++ /dev/null
@@ -1,112 +0,0 @@
-pub mod builder;
-
-use ngram_tools::iter::wordgrams::Wordgrams;
-use serde::{Deserialize, Serialize};
-use vector_space_model2::{index::Index, traits::Decodable, DefaultMetadata, Vector};
-
-#[derive(Deserialize, Serialize)]
-pub struct NGIndex<I: Decodable> {
-    pub(crate) index: Index<I, DefaultMetadata>,
-    n: usize,
-}
-
-impl<I: Decodable> NGIndex<I> {
-    pub fn new(index: Index<I, DefaultMetadata>, n: usize) -> Self {
-        Self { index, n }
-    }
-
-    pub fn query_vec(&self, query: &str) -> Option<Vector> {
-        let padded_query = padded(query, self.n - 1);
-        let terms: Vec<_> = Wordgrams::new(&padded_query, self.n).collect();
-        self.build_vec(&terms)
-    }
-
-    /// Searches in the index with the given query and returns an iterator over the results with the relevance, in random order.
-    pub fn find<'a>(&'a self, query: &'a Vector) -> impl Iterator<Item = (I, f32)> + 'a {
-        let dims = self.light_vec_dims(query);
-        self.index.get_vector_store().get_all_iter(&dims).map(|i| {
-            let sim = dice(query, i.vector());
-            (i.document, sim)
-        })
-    }
-
-    /// Searches in the index with the given query and returns an iterator over the results with the relevance, in random order.
-    /// Weigths the Vector lengths with the given value `w`
-    /// w = 1.0 -> query's length is being used only
-    /// w = 0.5 -> query's and results's length are equally important
-    /// w = 0.0 -> results's length is being used only.
-    pub fn find_qweight<'a>(
-        &'a self,
-        query: &'a Vector,
-        w: f32,
-    ) -> impl Iterator<Item = (I, f32)> + 'a {
-        let dims = self.light_vec_dims(query);
-        self.index
-            .get_vector_store()
-            .get_all_iter(&dims)
-            .map(move |i| {
-                let sim = dice_weighted(query, i.vector(), w);
-                (i.document, sim)
-            })
-    }
-
-    #[inline]
-    pub fn is_empty(&self) -> bool {
-        self.index.is_empty()
-    }
-
-    #[inline]
-    fn build_vec<S: AsRef<str>>(&self, terms: &[S]) -> Option<Vector> {
-        Some(self.index.build_vector(terms, None)?)
-    }
-
-    fn light_vec_dims(&self, vec: &Vector) -> Vec<u32> {
-        vec.vec_indices()
-            .filter(|dim| {
-                self.index
-                    .get_indexer()
-                    .load_term(*dim as usize)
-                    .unwrap()
-                    .doc_frequency()
-                    < 1000
-            })
-            .collect()
-    }
-}
-
-impl<D: Decodable> Default for NGIndex<D> {
-    fn default() -> Self {
-        Self {
-            index: Default::default(),
-            n: Default::default(),
-        }
-    }
-}
-
-#[inline]
-pub fn padded(word: &str, n: usize) -> String {
-    let pads = "§".repeat(n);
-    format!("{pads}{word}{pads}")
-}
-
-#[inline]
-fn dice(a: &Vector, b: &Vector) -> f32 {
-    let overlapping_cnt = a.overlapping(b).count() as f32 * 2.0;
-    overlapping_cnt / ((a.dimen_count() as f32) + (b.dimen_count() as f32))
-}
-
-/// Calculates the `dice` similarity using a weight score to allow giving a custom
-/// Weight distribution of the vector lengths.
-/// w = 1.0 -> `a`'s length is being used only
-/// w = 0.5 -> `a`'s and `b`'s length are equally important (same as [`dice`])
-/// w = 0.0 -> `b`'s length is being used only.
-#[inline]
-fn dice_weighted(a: &Vector, b: &Vector, w: f32) -> f32 {
-    let overlapping_cnt = a.overlapping(b).count() as f32 * 2.0;
-    let a_len = a.dimen_count() as f32;
-    let b_len = b.dimen_count() as f32;
-    let a_mult = w * 2.0;
-    let b_mult = (1.0 - w) * 2.0;
-    let nenner = (a_len * a_mult) + (b_len * b_mult);
-    overlapping_cnt / nenner
-}
